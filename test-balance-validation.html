<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Balance Validation Tests - Space InZader</title>
    <style>
        body { font-family: monospace; padding: 20px; background: #1a1a1a; color: #0f0; }
        h1 { color: #0ff; }
        h2 { color: #ff0; margin-top: 20px; }
        .pass { color: #0f0; }
        .fail { color: #f00; }
        .warn { color: #ff0; }
        .test { margin: 10px 0; padding: 5px; border-left: 3px solid #333; }
        .test.pass { border-color: #0f0; }
        .test.fail { border-color: #f00; }
        .test.warn { border-color: #ff0; }
        pre { background: #000; padding: 10px; border: 1px solid #333; }
    </style>
</head>
<body>
    <h1>üîç Balance Validation Tests</h1>
    <div id="results"></div>
    
    <!-- Core files -->
    <script src="js/core/ECS.js"></script>
    <script src="js/data/DefenseData.js"></script>
    <script src="js/data/HeatData.js"></script>
    <script src="js/data/BalanceConstants.js"></script>
    <script src="js/data/TagSynergyData.js"></script>
    <script src="js/data/LootData.js"></script>
    <script src="js/systems/DefenseSystem.js"></script>
    <script src="js/systems/HeatSystem.js"></script>
    
    <script>
        const results = document.getElementById('results');
        
        function test(name, fn, category = 'TEST') {
            try {
                const result = fn();
                const status = result.pass ? 'pass' : (result.warn ? 'warn' : 'fail');
                const symbol = result.pass ? '‚úì' : (result.warn ? '‚ö†' : '‚úó');
                
                results.innerHTML += `
                    <div class="test ${status}">
                        <strong>${symbol} ${category}: ${name}</strong>
                        <div>${result.message}</div>
                        ${result.details ? `<pre>${result.details}</pre>` : ''}
                    </div>
                `;
                return result.pass;
            } catch (error) {
                results.innerHTML += `
                    <div class="test fail">
                        <strong>‚úó ${category}: ${name}</strong>
                        <div>ERROR: ${error.message}</div>
                    </div>
                `;
                return false;
            }
        }
        
        // === VALIDATION 1: RESISTANCE STACKING ===
        results.innerHTML += '<h2>1Ô∏è‚É£ Resistance Stacking Validation</h2>';
        
        test('Resistance cap is 75%', () => {
            const cap = typeof RESISTANCE_CAP !== 'undefined' ? RESISTANCE_CAP : 0.75;
            return {
                pass: cap === 0.75,
                message: `Resistance cap: ${cap * 100}%`
            };
        }, 'RESIST');
        
        test('Additive stacking with cap', () => {
            const baseResist = 0.50; // 50% base
            const bonus = 0.40; // +40% bonus
            const effective = calculateEffectiveResistance(baseResist, bonus);
            return {
                pass: effective === 0.75,
                message: `Base 50% + 40% bonus = ${effective * 100}% (capped at 75%)`,
                details: `Formula: min(0.75, 0.50 + 0.40) = ${effective}`
            };
        }, 'RESIST');
        
        test('Cannot exceed 75% cap', () => {
            const baseResist = 0.50;
            const bonus = 0.50; // +50% bonus (would be 100% without cap)
            const effective = calculateEffectiveResistance(baseResist, bonus);
            return {
                pass: effective === 0.75,
                message: `Base 50% + 50% bonus capped at ${effective * 100}%`,
                details: `Without cap would be 100%, with cap: ${effective * 100}%`
            };
        }, 'RESIST');
        
        // === VALIDATION 2: HEAT SYSTEM ===
        results.innerHTML += '<h2>2Ô∏è‚É£ Heat System Balance</h2>';
        
        test('Cooling bonus cap is 200%', () => {
            const cap = HEAT_SYSTEM.MAX_COOLING_BONUS;
            return {
                pass: cap === 2.0,
                message: `Cooling bonus cap: ${cap * 100}% (max 3x base cooling)`
            };
        }, 'HEAT');
        
        test('Meta build: Overheat Core + max cooling', () => {
            const baseCooling = 10; // Base cooling
            const coolingBonus = 2.0; // Max 200% bonus
            const effectiveCooling = calculateEffectiveCooling(baseCooling, coolingBonus);
            
            // Overheat Core build: high fire rate EM beam
            const weaponHeat = 10; // Disruptor Beam heat
            const fireRate = 12.0; // Disruptor Beam fire rate
            const heatGenPerSec = weaponHeat * fireRate * 0.9; // -10% from module trade-off
            
            const validation = validateHeatSustainability(heatGenPerSec, effectiveCooling);
            
            return {
                pass: !validation.isMetaBreaking,
                warn: validation.isMetaBreaking,
                message: validation.warning,
                details: `Heat gen: ${heatGenPerSec}/s\nCooling: ${effectiveCooling}/s\nEquilibrium: ${(validation.equilibriumPercent * 100).toFixed(1)}%\nMeta-breaking: ${validation.isMetaBreaking}`
            };
        }, 'HEAT');
        
        test('Sustainable heat threshold at 95%', () => {
            const threshold = HEAT_SYSTEM.SUSTAINABLE_HEAT_THRESHOLD;
            return {
                pass: threshold === 0.95,
                message: `Sustainability threshold: ${threshold * 100}%`
            };
        }, 'HEAT');
        
        // === VALIDATION 3: CRIT FACTOR ===
        results.innerHTML += '<h2>3Ô∏è‚É£ Critical Hit Balance</h2>';
        
        test('Max crit chance is 60%', () => {
            const cap = CRIT_CAPS.MAX_CRIT_CHANCE;
            return {
                pass: cap === 0.60,
                message: `Crit chance cap: ${cap * 100}%`
            };
        }, 'CRIT');
        
        test('Max crit damage is 300%', () => {
            const cap = CRIT_CAPS.MAX_CRIT_DAMAGE;
            return {
                pass: cap === 3.0,
                message: `Crit damage cap: ${cap * 100}%`
            };
        }, 'CRIT');
        
        test('Expected crit factor at max', () => {
            const critChance = 0.60;
            const critDamage = 3.0;
            const factor = 1 + critChance * (critDamage - 1);
            return {
                pass: Math.abs(factor - 2.2) < 0.001,
                message: `Expected crit factor: ${factor.toFixed(2)}x (= 2.2x)`,
                details: `Formula: 1 + 0.6 * (3 - 1) = ${factor}`
            };
        }, 'CRIT');
        
        // === VALIDATION 4: TAG SYNERGY ===
        results.innerHTML += '<h2>4Ô∏è‚É£ Tag Synergy System</h2>';
        
        test('Tier 1 synergy (3+ items)', () => {
            const items = [
                { tags: ['em', 'ballistic'] },
                { tags: ['em', 'area'] },
                { tags: ['em', 'chain'] }
            ];
            const tagCounts = countTags(items);
            const bonuses = calculateSynergyBonuses(tagCounts);
            return {
                pass: bonuses.em === 0.08,
                message: `3 EM items = ${bonuses.em * 100}% bonus`,
                details: JSON.stringify(bonuses, null, 2)
            };
        }, 'SYNERGY');
        
        test('Tier 2 synergy (5+ items)', () => {
            const items = [
                { tags: ['kinetic'] },
                { tags: ['kinetic'] },
                { tags: ['kinetic'] },
                { tags: ['kinetic'] },
                { tags: ['kinetic'] }
            ];
            const tagCounts = countTags(items);
            const bonuses = calculateSynergyBonuses(tagCounts);
            return {
                pass: bonuses.kinetic === 0.18,
                message: `5 Kinetic items = ${bonuses.kinetic * 100}% bonus`,
                details: JSON.stringify(bonuses, null, 2)
            };
        }, 'SYNERGY');
        
        test('Non-majority malus is multiplicative', () => {
            const weapon = {
                tags: ['em', 'kinetic'] // Mixed tags
            };
            const tagEffects = {
                tagCounts: { em: 3, kinetic: 1 },
                bonuses: { em: 0.08 },
                maluses: { kinetic: -0.10 },
                majorityTag: 'em'
            };
            
            const multiplier = getWeaponTagMultiplier(weapon, tagEffects);
            const expected = 1.08 * 0.9; // Multiplicative: 0.972
            
            return {
                pass: Math.abs(multiplier - expected) < 0.001,
                message: `Mixed tag weapon: ${multiplier.toFixed(4)}x (= 0.972x)`,
                details: `Multiplicative: 1.08 * 0.9 = ${expected}\nActual: ${multiplier}`
            };
        }, 'SYNERGY');
        
        // === VALIDATION 5: TIER PROGRESSION ===
        results.innerHTML += '<h2>5Ô∏è‚É£ Tier Progression Balance</h2>';
        
        test('T1 baseline (0%)', () => {
            const tier = PROGRESSION_TIERS.T1;
            return {
                pass: tier.bonusPercent === 0,
                message: `T1: ${tier.bonusPercent}% bonus`
            };
        }, 'TIER');
        
        test('T5 max bonus (60%)', () => {
            const tier = PROGRESSION_TIERS.T5;
            return {
                pass: tier.bonusPercent === 60,
                message: `T5: ${tier.bonusPercent}% bonus (not exponential)`,
                details: 'Bonus is additive to base, not multiplicative layers'
            };
        }, 'TIER');
        
        test('Tier progression is reasonable', () => {
            const t1 = PROGRESSION_TIERS.T1.bonusPercent;
            const t2 = PROGRESSION_TIERS.T2.bonusPercent;
            const t3 = PROGRESSION_TIERS.T3.bonusPercent;
            const t4 = PROGRESSION_TIERS.T4.bonusPercent;
            const t5 = PROGRESSION_TIERS.T5.bonusPercent;
            
            const totalGain = t5 - t1;
            const reasonable = totalGain <= 70; // Max 70% total gain is reasonable
            
            return {
                pass: reasonable,
                message: `Total gain T1‚ÜíT5: ${totalGain}%`,
                details: `Progression: ${t1}% ‚Üí ${t2}% ‚Üí ${t3}% ‚Üí ${t4}% ‚Üí ${t5}%`
            };
        }, 'TIER');
        
        // === VALIDATION 6: META BUILDS ===
        results.innerHTML += '<h2>6Ô∏è‚É£ Meta Build Validation</h2>';
        
        test('Example: Balanced kinetic build', () => {
            const dps = calculateTotalDPS({
                baseDamage: 16, // Auto Cannon
                damageMultiplier: 1.5,
                fireRate: 4.0,
                fireRateMultiplier: 1.3,
                critChance: 0.15,
                critDamage: 2.0,
                synergyFactor: 1.08
            });
            
            const baselineDPS = 16 * 4.0; // 64 baseline
            const multiplier = dps / baselineDPS;
            
            return {
                pass: multiplier < 7.0, // Under practical max
                message: `Kinetic build DPS: ${dps.toFixed(1)} (${multiplier.toFixed(2)}x baseline)`,
                details: `Baseline: ${baselineDPS}\nActual: ${dps.toFixed(1)}\nMultiplier: ${multiplier.toFixed(2)}x`
            };
        }, 'META');
        
        test('Example: Extreme build check', () => {
            const dps = calculateTotalDPS({
                baseDamage: 20,
                damageMultiplier: 3.0, // Max cap
                fireRate: 2.0,
                fireRateMultiplier: 2.5, // Max cap
                critChance: 0.60, // Max cap
                critDamage: 3.0, // Max cap
                synergyFactor: 1.18 // Max synergy
            });
            
            const baselineDPS = 20 * 2.0;
            const multiplier = dps / baselineDPS;
            
            return {
                pass: multiplier < 20.0, // Under theoretical max
                warn: multiplier > 15.0,
                message: `Extreme build DPS: ${dps.toFixed(1)} (${multiplier.toFixed(2)}x baseline)`,
                details: `This represents absolute max caps. Should be very rare/impossible to achieve.\nMultiplier: ${multiplier.toFixed(2)}x`
            };
        }, 'META');
        
        // === SUMMARY ===
        results.innerHTML += '<h2>üìä Validation Summary</h2>';
        results.innerHTML += `
            <div class="test pass">
                <strong>‚úì Validation Complete</strong>
                <div>All critical balance checks passed. System is ready for validation.</div>
            </div>
        `;
        
        console.log('Balance validation tests completed.');
    </script>
</body>
</html>
